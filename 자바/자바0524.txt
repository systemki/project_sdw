변수 
 - 변수 선언 방법 
   타입 변수명;
 - 기본 타입종류와 값
 - 정수형 : int, char
 - 실수형 : double, float
   A*C / (B*D) 가금적 정수 끼리

 - 논리형 :  boolean

 - 일반 변수 
  - 기본타입으로 선언한 변수를 
  - 값을 저장
  - ==로 비교
 
- 참조 변수
  - 기본타입인 아닌 배열, 클래스, 열거형 으로 선언한 변수 
  - 주소를 저장 
  - 클래스인 경우 equals()메소드를 이용 하고\
  - 기본타입 배열은 ==로
  - 클래스 배열은 equals() 메소드로 이용하고,
  - 열거형은 == 를 이용한다. 
 
- 지역 변수 
  - 사용하는 지역이 일부(메소드 하나, 반복문 한곳 등)인 경우

- 멤버 변수   
  - 클래스의 멤버로,  사용하는 지역이 클래스 안 전체인 경우 
    (멤버 변수의 종류에 따라 사용 할 수 없는 메소드가 있을 수 있다)

- 매개 변수
 - 메소드를 동작시키기 위해 알려주는 정보를 (지역변수임)
 - 멤버변수와 매개변수의 우선 순위는 매개변수가 높다

- 클래스 멤버 변수 
  - static이 붙은 멤버 변수 
  - 클래스를 통해 호출

- 객체 멤버 변수
  - static 이 없는 멤버 변수 
  - 객체를 통해 호출(대부분 getter를 이용)

- 하나의 변수는 변수 종류 중 한가지만에 속하지 않음

 - 변수명 작성 규칙
 - 숫자로 시작할 수 없다.
 - 예약어를 사용할수 없다.
 - 특수문자는 $와 _만 가능 
 - 중복 선언이 불가능
 - 대소문자를 구별한다

 - 변수명 작성 관례
 - 변수명은 소문자로 한다. (단 상수는 대문자임) fianl같은건 대문자로 함 
 - 카멜 표기법 : 변수명이 두단어 이상으로 되어 있을 때 두번째 단어부터 
   첫글자만 대문자로 표기하는것 
 - 클래스는 첫글자로 대문자 한다.
 - 변수명/메소드/클래스명은 의미있는 단어로 작성 하는게 좋다.
 


연산자 
 - 연산자 종류와 결과 
 - 산술연산자 
  - +, -, *, %
  -  정수 / 정수 > 정수가 되어서 소수점이 사라짐(정확하지 않음)
  타입 변환 통해서 (double)정수 /정수 > 실수가 되도록 해야한다.
  - % : 나머지를 확인 하는 연산자로 말로 표현 했을 때 나누었을 때 나머지 해당
  - 산술 연산자의 계산 결과값은 값 
 
 - 대입 연산자
  - = 
  - 오른쪽에 있는 값을 왼쪽에 저장 
  - 왼쪽에서는 변수가 1개 와야 함           
  - 저장, 덮어쓴다, 초기화 등의 표현
  - 대입 연산자는 값 또는 주소값 

- 증감연산자 

 - ++, --
 - 최종적으로 1증가 / 1감소
 - 전위형 : 증감하고 동작
 - 후위형 : 동작하고 증감 
 - 증감 연산자 결과값은 값

- 비교 연산자
  ->, < >= <=, ==, !=
  - 크키 비교 
  - 일반 변수의 크기를 비교 할 때 사용
  -  비교 연산자 결과값은 참 또는 거짓 (논리 값)
  ==와 대입연산자와 =을 혼동하지 말자

- 논리 연산자
 - &&, ||, !
 - && : ~하고  ~이고 둘다 참이면 참 나머지는 거짓 
 - || :  ~ 하거나, 이거나 둘다 거짓이면 거짓 나머지는 참
 - ! :  아닌 반대에 개념 , 참이면 거짓, 거짓이면 참 
 - 논리 연산자 결과값은 참 또는 거짓 (논리 값)
 - 조건 선택 연산자
   -( 조건식)? (참) : (거짓)
   - 조건식이 참이면 (참) 해당하는 부분을 거짓이면 (거짓)에 해당하는 
     부분을 실행 

 - 조건식 
   - 연산 결과가 참 또는 거짓이 되는 식 

- 연산자 우선 순위
  - 우선순위는 ()가 제일 높다
     num < 2 && num == 2
   
int num = 10;
boolean is Even = false;

if

       && 참거짓 구분할 부분이 와야 하는데 	
if(num = 10 && num < 10){
	//실행문  


조건문
 -  ~ 하면... 해라
 - ~ : 조건식  ...: 실행문
 - 조건문의 종류 if문, switch문 
 - if문 
  -if문 문법
if(조건식1){
	실행문;
}else  if (조건식2){
	실행문;
}else{
실행문3;
}
 if: 무조건 한개
else if: 0개이상
else : 0개 또는 1개 
 - 위의 문법에서 조건식1과 조건식2를 같이 만족하는 경우에 실행되는 실행문은? 1번문 실행됨
 
많이 실수하는  장면1
             ;세미콜론 주의
if(조건식1);{
	실행문1;
}else {
	실행문;
}


switch문 
 - 사용하는 변수(식)의 값이 제한적일 때 

 - switch 문법
switch(변수/식){
case 값1:
	실행문1;
break;
case 값2:
	실행문2;
break;
default:
	실행문3;
}
 break; : switch 문을 빠져 나오는 역할
 switch문에서 break 를 만나지 못하면 다음 실행문 으로 이동 


반복문 
 - 규칙적인 작업을 여러번 할 때 사용
 - 반복횟수 , 규칙성 찾아야 한다.
 - for문, while문, do while문 
- for문
 - 문법안에서 초기화, 조건식, 증감식을 입력하는 위치가 있다.
 - 초기 화 : 반복문에서 사용 하는 변수를 초기화, 생략 가능
 - 조건식 : 반복문 동자을 결정하는 곳으로 참이면 반복문 동작, 거짓이면
  	  반복문 종료 , 생략 가능 하며 생략하면 항상 참 
 - 증감식 : 조건식에서 사용 하는 변수를 증감 하거나 감소 시킴 (생략가능)
 - 초기화, 조건식, 증감식이 반복회수를 결정 한다.


for문 
for(초기화 ;조건식; 증감식){
	실행문;
}

- while문 
- (강사는) 반복횟수가 정해져 있지 않거나, 순차적으로 증감식 없는 경우  while문을 이용 
  -  조건식은 생략 불가능 	

while(조건식){
실행문;
}


- do while문
 - 무조건 한번은 실행
 - ;이 들어 간다
 - do while문 기본 문법

do{
	실행문;
}while(조건식);


- 반복문 사용시 유의 사항
 - 의도치 않은 무한루프가 생기지 않도록 주의
 - 조건식을 잘못 지정해서 실행되지 않는 경우가 생기지 않도록 주의

while(menu !=3);
}

향상된 for문
- 배열이나 리스트 일때 향상된 for문을 사용 할수 있다.
- 배열이나 리스트의 원소들을 전체 탐색할 때 사용 

- 향샹된 for문 문법 
for(타입 변수명 : 배열이나 리스트 ){
실행문;

}

- break; 
 - switch문/반복문을 빠져 나가는 역할
 - 반복문에서는 if문과 세트로 같이 나온다.

- continue
-for문에서 증감식위치로 점프(스킵), while문에서는 조건식 위치로 스킵
- if문과 세트로 같이 나옴
- continue를 만나면 아래 코드가 있더라 실행하지 않고 지정된 위치로 이동


   배열 
 - (같은 의미)타입 변수들의 집합 
 - 배열은 변수들을 효율적으로 관리하기 위해 사용 
 - 배열은 참조변수 
 - 배열의 시작번지 0번지 부터 크키 -1번지 까지 
 - 배열에서 번지를 잘못 사용하면 ArrayIndexOutOfBounds  예외가 발생
 - 배열의 길이는 배열명.lenght로 알수 있다.
 - 배열은 반복문과 같이 사용 된다

클래스 
 - 메소드
 - 하나의 기능을 하도록 모아놓은 코드
 - 매개변수 : 메소드를 실행하기 위해 필요한 정보
 - 리턴 타입 : 메소드 실행후 알려주는 정보
 - 메소드 선언부 

메소드 선언 : 리턴타입  메소드명(매개변수){}
		메소드 		
	- 리턴값은 해당 메소드를 호출한 메소드에게 알려줌 
	- 리턴 값이 없는 경우 void를 사용 
	- 매개변수 값 또는 주소값을 복사해서 사용 
	- 매개변수가 일반 변수인 경우 원래값(메소드를 호출한 곳에서 알려준 값)이 변경이 안된다.
	- 매개변수가 참조변수인 경우 원래 값이 변경 될수 있다.
	- 메소드 오버로딩
   	   - 동일한 이름의 메소드가 여러개 존재 할수 있다.	
	   - 매개 변수가 갯수가 다른경우 
	   - 매개 변수의 타입이 다른경우 

- 멤버 변수 
- 클래스에서 나타낼 정보 
- 멤버 메소드에서 멤버변수를 이용하여 동작
- 멤버변수는 생성자에서 초기화 할수 있다.
- 멤버변수가 참조 변수이면 객체를 꼭 만들어 놓아야 한다.
  - 명시적 초기화 또는 생성자 또는 초기화 블록
 

 - 생성자 
 -  멤버변수 들을 초기화 하는곳
 -  일반적으로 접근제한자가 public
 -  이름이 클래스명과 동일
 -  리턴타입을  사용하지 않음
 -  new를 이용하여 객체를 생성할 때 호출
 -  객체 생성 후 임의로 호출할 수 없다
 -  생성자 오버로딩을 통해 다양한 형태의 생성자르 만들 수 있다.
 - 생성자가 없으면 기본 생성자가 만들어 진다.
 - 객체 선언 및 생성

클래스명 객체명 = new 클래스명();
- 객체는 생성을 해야 멤버 메소드와 멤버변수르 사용 할수 있습니다.
- 객체를 생성 하지 않고 메소드와 멤버 변수를 사용하면 NullPointer
   예외가 발생한다.

- 멤버 메소드를 호출 하는 방법
객체명.메소드명(매개변수);
- 접근제한자 
  - public    	: 본인 + 같은패키지 + 자식 + 다른 패키지
  - protected 	: 본인 + 같은패키지 + 자식 
  - 디폴트		: 본인 + 같은패키지
  - private 	: 본인

 - static 
 - 멤버 변수 /메소드를 클래스 멤버 변수/메소드로 만듬
 - 클래스 변수/메소드는 모든 객체가 공유함
 - 클래스 변수/메소드는 클래스당 1개만 존재 (한개가 모드 공유함)
 - static이 안붙은 멤버 변수/메소드를 객체 멤버 변수/메소드라 함
 - 객체 변수 /메소드는 각  객체마다 가각 1개씩 존재
 - 클래스 변수는 객체 메소드에서 사용할 수 있다.
 - 객체 변수는 클래스 메소드에서 바로 사용 할수 없다.
 - 클래스 메소드는 객체 메소드에서 사용할 수 있다.
 -  객체 메소드는 클래스 메소드에서 바로  사용 할수 없다.


클래스에서 객체로 사용 가능 하지만
객체에선 클래스에서 바로  사용 할수 없다.
클래스 변수 /메소드는 객체 없이 호출이 가능하지만
객체 변수/메소드는 객체가 있어야 호출이 가능하다.

- final
 - 변할 수 없다.
 - 변수	: 상수로 된다.
 - 메소드	: 오버라이딩을 할 수 없음
 - 클래스	: 부모클래스 될수가 없다.

상속 
 - 부모클래스의 멤버 변수 / 메소드를 물려 받는것
 - extends 키워드를 이용해서 상속
 - 코드를 중복을 제거
 - 쉽게 클래스를 만들기 위해서
 - 서로 다른 자식 클래스들의 객체들을 부모 클래스가 쉽게 관리하기 위해서
 - 클래스 상속에서 부모는 한클래스만 가능
 - 인터페이스 상속에선 부모는 여러 인터페이스 가능 
 - 메소드 오버라이딩 
   - 부모클래스에 있는 메소드를 자식 클래스 에서 재정의 하는 것
   - 부모 클래스의 메소드 선언부가 동일해야 한다. (매개변수, 리턴타입이 동일)
   - 접근제한자는 좁은 범위로 줄일 수 없다.
	- 부모 클래스 메소드의 접근제한자가 public이면 해당 메소드를 
  	   자식 클래스에서 오버라이딩 할때 접근제한자는 public만 가능
	   디폴트, protected, private으로 변경 불가능

 -  ※클래스 타입 변환
   - 클래스 타입 변환은 부모와 자식 관계에서 가능 
 - 자동 : 자식 클래스의 객체를 부모 클래스의 객체로 변환하는 경우

 - 강제(조건)
Parent p = new Child();
 - 강제(조건) : 부모 클래스의 객체를 자식 클래스의 객체로 변환하는 경우
Parent p =new Child();
child c = (Child)p;

추상 클래스
 - Calendar
 - abtract를 붙여줌
 - 추상 클래스는 객체를 생성할 없음. 자식 클래스를 이용하여 객체를 생성
 - 추상 메소드 
   - 메소드 선언부만 있고 구현부가 없음 메소드
   - 자식 클래스에서 무조건 오버라이딩 해야한다. (자식 클래스가 일반 클래스인 경우)

 인터페이스 
 - 상수와 추상메소드로 이루어져 있음
 - 인터페이스를 이용하여 객체를 생성 할 수 없다.
 - 인터페이스를 이용하여 구현 클래스를 만든다. implements를 사용 
 - 구현 클래스를 만들 때 여러 인터 페이슷 구현해도 된다.
 - 구현 클래스에서는 인터페이스에 있는 메소들을 오버라이딩 해야한다.
 - 기능 명세서

익명 객체 

- 클래스를 상속 받아서(인터페이스를 구현해서) 이름 있는 클래스로 만드는 것이 아니라
   한번 사용할 용도로 이름 없는 클래스를 만들어 객체를 생성하는 것
- 익명 객체를 사용하는 경우 새로운 멤버 변수/메소드를 생성하지 않고
   부모 클래스에 있는 메소드나 인터페이스에 있는 메소드를 오버라이딩해서 사용 

A a = new A(){
	//멤버변수와
	//멤버메소드

};
   

예외 처리 
 - 프로그램이 중단되는 것 막기 위해
 - 예외 상황을 발견하고 그 상황을 해결하기 위해
 - 예외 : 코드로 해결이 가능 한 부분
 - 오류 : 코드로 해결 할 수 없는 부분

 - 일반예외 : 컴파일 단계에서 확이 되어 실행되지 않는 예외 
 - 실행예외 : 컴파일 단계에서 확인 되지 않고 실행 과정에서 나타는 예외
 - 실행예외는 예외처리를 하지 않아도 에러가 발생하지 않음.
    일반예외는 예외처리를 아지 않으면 에러가 발생함

- 배열 ArrayIndexOutOfBounds
- 참조 :  NullPointer 
- 나누기 : Arithmetic 
- 타입 변환 : classCast
- 문자열을 숫자로 : NumberFormat
- 예외처리 방법1 : try catch

try{
	예외가 발생할 수 있는 코드;
}catch(예외클래스명1 e){
	예외처리문;
}catch(예외클래스명2 e){
	예외처리문;
}finally{

	실행문;
}

 - 이때 예외클래스명 1은 예외클래스명2의 조상클래스이면 안됨
 - finally는 예외처리 과정에서 메소드가 종료되도 무조건 실행 됨
 예외처리 방법 2 :  throws
  - 예외가 발생하면 직접 처리 하지 않고 예외를 던져서 남이 처리하게 하는 방법
 - 메소드 선언부에서 매개변수 옆에 throws예외 클래스명을 입력하여 
   발생할수 있는 예외를 알려줌
 - 단, 실행예외인 경우 throws 를 생략할수 있음
 - 예외 던지기 : throw 
 - 자동으로 발생되는 예외가 아닌 변수에 조건에 따라서 예외를 발생시키고자 
   할때 사용
 - throw는 예외 객체를 던져야 하기 때문에 일반적으로 
 - throw new 예외 클래스명("예외메시지"); 형태로 던진다.

기본 API클래스
 - Object
   모든 클래스의 조상 클래스
   equals(), toString()
 - String
  문자열이 있는지 확인 하는 메소드
   indexOf()
   contains()
   문자열이 같은지 확인하는 메소드 : equals()
   구분자를 기준으로 문자열을 추출하여 배열로 만드는 메소드 : split()
   문자열의 길이를 확인하는 메소드 : lenght()
 - Math
   울림	: ceil()
   버림	: floor(0
   반올림	: round(), rint(0
   램덤	: random()
 - Date
   날짜를 문자열로
   문자열 날짜로 
 - Calender
   달력 
   년, 월 , 일, 시, 분, 초등 다양한 값들을 확인할 수 있다.
   추상클래스

제네릭 클래스 
  - 클래스의 멤버 변수 또는 메소드의 타입이 객체를 선언 할때 결정되는 클래스 
     <>로 클래스 명이 필요하다. 생략하면 <Object>를 한거와 같다.


컬렉션 프레임 워크

  - 자료들을 효율적으로 관리하기 위한 것

  - List, Set, Map : 인터페이스 
  - List와 Set은 한종류의 데이터를 관리, Map은 2종류의 데이터를 관리 
  - LIst : 순서 보장, 중복 가능 (일반적으로 사용)
  - Set : 중복 불가능, 순서를 보장 하지않음 
  - Map : key과 vlaue로 이루어짐. key는 중복 불가. value는 중복 가능 
   
List : 인터페이스 
 - 순서 보장, 중복 가능 
 - 멤버 메소드 
 - 향상된 for문을 이용할 수 있다.

 - ArrayList
  - List의 구현 클래스 
  - 배열로 된 리스트
  - 탐색이 빠르다
  - 중간 삽입/삭제가 느리다

- LinkdList 
  - List의 구현 클래스 
  - 연결도 된 리스트  
  - 탐색이 느리다.
  - 중간 삽입/삭제가 빠르다
  - Iterator를 이용하여 값들을 가져올 수 있다.

Set : 인터페이스 
 - 중복 불가능, 순서보장 x
 - 구현 클래스 HashSet (멤버 메소드)
 - Hash코드를 이용하여 먼저 확인 한 후 equlas()를 이용하여 확인
 - Iterator를 이용하여 반복문을 사용해야 값들을 가져올 수 있다.
 - List에 잇는 get()메소드가 없기 때문에 lterator를 이용하지 않고는 값을 확인할 수 없다.   	
	HashSet<Integer> set = new HashSet<Integer>();


Map 
  
 - 두 종류의 데이터를 저장  key와 value
 - key는 중복 불가, 
 - va1lue는 중복가능
 - 순서를 보장 하지 않음
 - 이미 있는 key값에 중복으로 데이터를 넣으면 최신 데이터로 덮어 쓴다.
 - 값들을 확인하기 위해  Set으로 변환시켜야 된다
 - key값들을 Set으로 만들어서 확인
 -  Entry = key , value 묶어  클래스를 셋으로 만들어짐 

 - 출력 할떄 조금 복잡
 - HashMap
 - Map 구현 클래스












